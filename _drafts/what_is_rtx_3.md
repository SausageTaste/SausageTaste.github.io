---
layout: post
title:  "RTX란 무엇인가 3편 - GeForce RTX 튜링 아키텍처"
comments: true
use_math: false
---

*이미지를 클릭하시면 이미지 출처 페이지로 이동합니다. 클릭되지 않는 이미지의 저작권은 제게 있습니다.* <br>
*Click image to go to the page where I found it. Non clickable images are created by me.* <br>

지금까지 레이트레이싱의 원리에 대해 간단하게 알아봤습니다.
복잡한 내용이 많아 잘 기억에 안 남는 부분이 많을 것입니다.
내용을 확실하게 이해하려면 같은 내용을 두번 세번 반복해서 읽어야 할 수도 있습니다.

하지만 이번 글의 내용을 이해하려는데 이전 두 글의 내용을 완벽하게 암기하고 있을 필요는 없습니다.
이 두 가지만 떠올려 주세요.

* 레이트레이싱은 기본적으로 선분과 삼각형 사이의 접점을 찾는 수학적 과정이다.
* 공간에는 삼각형이 너무 많기 때문에 상자 도형을 이용해 접점 존재 가능성이 없는 삼각형을 추려낸다.

이 두 개념이 중요한 이유는 RTX 그래픽카드가 수행하는 일이 정확하게 이것이기 때문입니다.
그럼 지금부터 RTX 그래픽카드의 내부에 대해 자세히 알아보겠습니다.

# RTX GPU

우선 용어부터 확실히 정리하겠습니다.
일반인에게는 그래픽카드가 더 익숙한 이름이겠지만, 사실 그래픽카드는 여러가지 요소가 하나의 제품으로 합쳐진 복합체입니다.
정리하자면 그래픽카드 자신의 CPU와 RAM을 별개로 갖고 있는 셈이 됩니다.

* GPU : 연산을 수행하는 유닛으로 CPU와 같은 포지션
* VRAM : AAA 게임의 그래픽 설정에 자주 보이는 것으로, GPU가 연산을 수행하는 데 필요한 정보를 저장하는 곳으로 RAM과 같은 포지션

이번 글에서는 GPU에 집중하려고 합니다.
GPU가 VRAM과 빠르게 통신하는 기술, 수천 개의 GPU 코어가 하나의 VRAM과 통신하면서 순서가 꼬이지 않게 하는 기술 등의 복잡한 내용들은 범위 밖의 내용입니다.
저희는 순수하게 GPU 안에만 들어있는 것들에 대해 알아볼 것입니다.

지금부터 RTX 그래픽카드라 하지 않고 RTX GPU라는 용어를 주로 사용하겠습니다.
그리고 RTX 이전의 것, 우리가 오랫동안 사용해 오던 것들은 GTX GPU라고 부르겠습니다.
정식 명칭은 아닙니다.
맥스웰 아키텍처, 튜링 아키텍처라는 공식 용어가 있긴 합니다만.
별로 안 익숙하잖아요?
그냥 RTX랑 GTX라고 부르는 게 더 쉬울 거라 생각했습니다. ^^

# GPU가 하는 일

앞서 GPU가 CPU와 같은 포지션이라고 설명 드렸습니다.
구체적으로 말하자면 GPU는 실수(real number, 實數)의 덧셈, 곱셈, 제곱근 등의 연산을 매우 빠르게 수행합니다.
이 이상 자세히 이해하기는 일반인 입장에서 쉽지 않습니다.

어쨌든 저희의 목적은 RTX에 대해 이해하기잖아요?
RTX 이전의 GPU와 RTX GPU 사이의 차이점이 우리의 큰 관심사입니다.
GPU에 대해 자세히 이해할 필요는 없습니다.
그러니 여기서는 RTX GPU만이 가진 특별한 점만을 짚어보겠습니다.

![sm_of_turing_architecture](https://www.gamersnexus.net/images/media/2018/gpus/2080-ti/arch/sm-architecture-block-diagram.jpg)

위 그림이 RTX의 SM(Streaming Multiprocessor) 하나의 구조입니다.
하나하나 뜯어봐도 뭐가 뭔지 감도 안 옵니다.
이 그림에 포함된 정보를 모두 이해할 필요는 없습니다.
이해하기 쉬우면서 흥미로운 부분만 골라서 살펴봅시다!

# GTX와 RTX의 공통점

## 부동소수점 연산

그림에서 초록색 상자 안에 흰 글자로 **FP32**라고 적혀 있는 곳이 보이시나요?
이것은 *floating point number 32 bit*의 줄임말인데요.
프로그래밍에 대해 아시는 분이라면 float 타입의 숫자를 의미한다는 걸 바로 눈치채셨을 겁니다.
`float`이 뭔지 잘 모르신다면 그냥 **실수(real number, 實數)**라고만 알고 계시면 되겠습니다.

결론부터 말하자면, 이 부분은 GTX와 RTX의 공통점 되겠습니다.
FP32 코어는 GTX에서는 그냥 코어란 이름으로 내장되어 있습니다.
개수도 그리 큰 차이가 나지는 않습니다.
그럼에도 불구하고 언급하는 이유는, 이 장치가 GPU의 존재 의의이기 때문입니다.
이것이 뭔지 이해하는 것이 GPU 그 자체에 대해 이해하는 데 아주 중요합니다.

실수의 연산은 컴퓨터 그래픽스에서 가장 중요한 요소입니다.
구체적으로 실수의 연산이 어떻게 사용되는지 예시를 들어보겠습니다.

* 저번 글에서 보셨들이 모든 3차원 물체는 실수(real number)로 표현됩니다.
* 물체를 공간 안에서 이리저리 이동하고 애니메이션을 적용할 때 행렬곱을 사용하는데, 이것도 내부를 보면 숫자의 덧셈과 곱셈이죠.
* 물체의 표면에 빛 효과를 적용하는 것은 벡터의 내적, 제곱근, 그리고 덧셈과 곱셈으로 이루어져 있습니다.
  벡터는 보통 3~4개의 실수로 표현되죠.
* 그림자는 물체의 위치 정보를 행렬곱을 적용하여 텍스처에 저장, 나중에 이를 역행렬로 되찾아서 값의 대소 비교를 통해 구현됩니다.
  역시나 대부분 실수의 연산이지요.
* 레이트레이싱 없이 구현하는 반사 효과도 마찬가지입니다.
  물체의 위치 정보와 색깔 정보를 행렬곱을 적용해 텍스처로 저장한 뒤, 벡터 연산을 통해 올바른 반사상의 위치를 찾아냅니다.

저도 일개 프로그래머에 불과해서 이 FP32 장치가 구체적으로 어떻게 작동하는지는 모릅니다.
일단 대학 컴퓨터시스템 시간에 배운 내용을 토대로 유추해 보자면 이렇습니다.
FP32 안에는 몇 개의 논리회로가 들어 있습니다.
실수를 32 비트 `float`의 형태로 이 논리회로에 입력하고, 덧셈을 원하는지 곱셈은 원하는지를 전기신호로 입력해 주면 그 결과값을 돌려주는 방식일 것입니다.
CPU 안에 들어 있는 FPU과 비슷하지 않을까 생각합니다.

> 추후 자료 조사를 하여 내용을 추가할 예정

실수의 연산은 그래픽 연산 과정의 90% 이상을 차지합니다
GTX나 RTX 둘 다 실수 연산을 담당하는 FP32 하드웨어를 수천 개 때려박아 같은 시간 안에 연산량을 늘리려고 노력합니다.
레이트레이싱도 실수의 연산을 굉장히 많이 하기 때문에, 이 부분은 GTX와 RTX 사이의 차이가 거의 없는 부분이 되겠습니다.
(물론 더 최근에 나온 RTX GPU에 장착된 FP32가 좀 더 성능이 좋겠지만요.)

# 차이점

여기서부터는 GTX와 RTX의 차이점입니다.

## 정수 연산

위 그림에서 FP32 옆에 INT32가 있죠?
이것은 *integer 32 bit*의 약자인데요.
Integer의 뜻은 **정수**입니다.
`… -2, -1, 0, 1, 2, 3 …`처럼, 자연수에 0과 음수가 추가된 수의 영역 아시죠?
정수에 대한 연산을 담당하는 하드웨어가 RTX에 와서 아주 중대한 업그레이드를 받았답니다.

그런데 프로그래머가 아닌 분들은 여기서 의문이 드실 겁니다.
정수 연산을 하는 하드웨어가 왜 필요한가?
고등학교 수학 수업을 열심히 들었다면 기억하시겠지만, 실수는 모든 정수를 포함하죠.
그러니 그냥 `3 + 5`의 결과를 알고 싶으면 FP32에 넣어서 `3.0 + 5.0 = 8.0`이라는 결과를 얻으면 안 될까요?

사실 정수 연산이 필요한 이유가 다 있습니다.
실수 연산을 위해 사용하는 float형 숫자는 정밀도 문제를 갖는다는 지극히 기술적인 문제도 있습니다만.
레이트레이싱을 수행할 때 정수 연산이 중요하게 사용된다는 것도 원인이이죠.

삼각형과 광선의 교점 찾기 같은 연산은 실수 연산이 맞습니다만.
광선이 어떤 삼각형과 충돌했는지, 그 삼각형이 어떤 바운딩 볼륨 안에 있는지를 나타낼 때 정수를 사용합니다.
위와 같은 논리 연산을 수행할 때는 대부분 정수 연산이지요.
그래서 효율적으로 레이트레이싱을 수행하려면 효율적으로 정수 연산을 할 필요가 있는 것입니다.

GTX에서 정수 연산을 수행하는 장치가 있습니다.
하지만 RTX에서 크게 개선된 점은, 정수 연산을 병렬로 수행할 수 있다는 점입니다.
즉, INT32가 열심히 정수 연산을 하고 있는 동안 그 옆에 있는 FP32는 다른 셰이딩 연산을 하고 있을 수 있다는 뜻입니다.
GTX에서는 정수 연산을 수행하려면 실수 연산을 올스톱 해야 한다네요. ㄷㄷ

## RT Core

드디어 대망의 RT 코어까지 왔습니다.
이름만 봐도 딱 눈치가 옵니다.
이것이 바로 레이트레이싱 관련 연산을 수행하는 하드웨어 장치입니다.
현대의 게임에서 볼 수 있는 아름다운 반사, 실시간 글로벌 일루미네이션의 마술은 바로 여기서 일어나는 것이지요.

RT 코어는 두 가지 종류의 계산을 합니다.

* 광선과 삼각형 사이의 교점 구하기
* 바운딩 볼륨 계층에서 광선이 충돌할 가능성이 있는 볼륨 찾기

광선과 삼각형 사이의 교점 구하기가 뭔지는 바로 아시겠죠?
두 번째 항목이 어려운 용어도 있어서 좀 복잡한데요.
사실 이미 배운 내용입니다.
여러 개의 삼각형을 하나의 박스로 묶은 뒤, 광선과 박스가 충돌하지 않으면 내부의 삼각형을 모두 무시하는 전략 기억하시죠?
RT 코어는 이 박스와 광선의 충돌 검사를 수행하여 충돌한 박스를 반환하는 역할도 수행할 수 있다는 뜻입니다.

RTX 이전에는 FP32처럼 실수 연산을 수행하는 장치가 위의 작업도 겸했습니다.
광선과 삼각형의 교점 구하기는 3차원 벡터의 내적, 외적, 거리 측정을 사용하는데 모두 실수의 연산이죠.
광선과 박스의 충돌의 경우도 실수의 연산을 사용하여 구현합니다.
Nvidia가 구체적으로 어떻게 구현했는지는 잘 모르겠지만, 분리축 정리(separating axis theorem)을 사용했다면 역시나 벡터의 내적과 외적이 주로 사용되었을 겁니다.

그런데 레이트레이싱은 아주아주 시간이 오래 걸리는 작업입니다.
광선과 물체의 교차 검사를 한다고 FP32 코어를 달달 볶으면 다른 셰이딩 연산을 할 귀중한 시간을 뺐기는 꼴이 됩니다.
그래서 RT 코어를 도입하여 레이트레이싱 연산을 수행할 코어를 별도로 제공함으로써 이 문제를 해결한 것입니다.

## Tensor Core
